# GMatch 设计文档

## 系统架构

GMatch是一个基于C++17的游戏匹配服务，采用客户端-服务器架构。系统由以下主要组件构成：

```
+-------------+       +----------------+       +-------------+
|             |       |                |       |             |
|   客户端    +------>+    匹配服务器   +------>+    房间     |
|             |       |                |       |             |
+-------------+       +----------------+       +-------------+
                              |
                              v
                      +----------------+
                      |                |
                      |   匹配引擎     |
                      |                |
                      +----------------+
```

### 核心组件

1. **Player（玩家）**
   - 表示一个游戏玩家
   - 包含玩家ID、名称、评分等属性
   - 提供状态管理功能

2. **Room（房间）**
   - 表示一个游戏房间
   - 管理房间内的玩家
   - 处理玩家加入/离开逻辑
   - 支持房间状态变更

3. **MatchMaker（匹配器）**
   - 负责玩家匹配逻辑
   - 实现基于评分的匹配算法
   - 管理匹配队列
   - 处理超时逻辑

4. **MatchManager（匹配管理器）**
   - 协调整个匹配过程
   - 管理玩家和房间的生命周期
   - 处理匹配请求
   - 提供查询接口

5. **RequestHandler（请求处理器）**
   - 处理客户端请求
   - 解析JSON消息
   - 执行业务逻辑
   - 返回结果

6. **MatchServer（匹配服务器）**
   - TCP服务器实现
   - 管理客户端连接
   - 处理网络I/O
   - 路由请求到请求处理器

7. **MatchClient（匹配客户端）**
   - 客户端库
   - 提供与服务器交互的API
   - 处理连接和断开
   - 封装请求和响应逻辑

## 匹配算法

GMatch使用基于评分（Rating）的匹配算法，以确保玩家之间的平衡性。匹配过程如下：

1. 玩家加入匹配队列，提供自己的评分值
2. 匹配引擎周期性检查队列中的玩家
3. 对于每个玩家，尝试在队列中寻找评分接近的其他玩家
4. 评分差异在可接受范围内的玩家被组成一个房间
5. 如果一定时间内未找到合适的匹配，可能会扩大评分差异范围
6. 当房间达到所需人数时，匹配完成，房间状态变为"已匹配"

算法伪代码：

```
function match_players():
    for each player P in queue:
        for each other player Q in queue:
            if abs(P.rating - Q.rating) <= MAX_RATING_DIFF:
                if room has space:
                    add Q to room with P
                if room is full:
                    mark room as matched
                    remove players from queue
                    break
    
    for each unmatched player P in queue:
        if P.time_in_queue > TIMEOUT:
            expand_rating_range(P)
```

## 通信协议

GMatch使用JSON作为通信协议。客户端和服务器之间的通信基于以下消息格式：

### 请求格式
```json
{
    "cmd": "命令名称",
    "data": {
        // 请求参数
    }
}
```

### 响应格式
```json
{
    "status": 0,  // 0表示成功，非0表示错误码
    "msg": "OK",  // 状态消息
    "data": {
        // 响应数据
    }
}
```

### 主要命令

1. **create_player**: 创建玩家
   ```json
   {"cmd": "create_player", "data": {"name": "Player1", "rating": 1500}}
   ```

2. **join_queue**: 加入匹配队列
   ```json
   {"cmd": "join_queue", "data": {"player_id": "12345"}}
   ```

3. **leave_queue**: 离开匹配队列
   ```json
   {"cmd": "leave_queue", "data": {"player_id": "12345"}}
   ```

4. **get_rooms**: 获取房间列表
   ```json
   {"cmd": "get_rooms", "data": {}}
   ```

5. **get_player_info**: 获取玩家信息
   ```json
   {"cmd": "get_player_info", "data": {"player_id": "12345"}}
   ```

6. **get_queue_status**: 获取队列状态
   ```json
   {"cmd": "get_queue_status", "data": {}}
   ```

## 并发模型

GMatch采用基于线程池的并发模型：

1. 主线程负责网络I/O，接受新连接
2. 工作线程池处理客户端请求
3. 匹配线程周期性执行匹配算法
4. 使用互斥锁保护共享数据

```
+----------------+      +------------------+
|                |      |                  |
|   主线程       +----->+   客户端处理线程  |
| (接受连接)     |      |                  |
|                |      +------------------+
+-------+--------+
        |
        v
+-------+--------+
|                |
|   匹配线程     |
|                |
+----------------+
```

## 配置系统

GMatch使用基于INI文件的配置系统，支持以下配置项：

1. 服务器地址和端口
2. 匹配参数（每房间玩家数、最大评分差异等）
3. 日志级别和输出文件
4. 线程池大小
5. 队列超时时间

## 扩展性考虑

GMatch设计时考虑了以下扩展点：

1. 可插拔的匹配算法，支持自定义匹配逻辑
2. 支持添加新的命令和功能
3. 可扩展的玩家属性系统
4. 可定制的房间规则
5. 支持添加数据持久化层

## 性能优化

为确保高性能，GMatch实现了以下优化：

1. 使用无锁数据结构减少竞争
2. 批量处理匹配请求
3. 使用连接池管理客户端连接
4. 优化匹配算法复杂度
5. 使用内存池减少内存分配开销 